#include <glew.h>
#include <glfw3.h>

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <numeric>

#include "shaderLoader.h"
#include "fileReader.h"

//funkcje algebry liniowej
#include "glm/vec3.hpp" 
#include "glm/vec4.hpp" 
#include "glm/mat4x4.hpp" 
#include "glm/gtc/matrix_transform.hpp"

using namespace std;

// Camera things
glm::vec3 cameraPos = glm::vec3(0.0f, 0.0f, 200.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -50.0f);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);
float fov = 45.0f;

const float cameraSpeed = 0.7; // adjust accordingly
const int rotationMultiplier = 1;

// Light things
GLuint objectColor_id = 0;
GLuint lightColor_id = 0;
GLuint lightPos_id = 0;
GLuint lightStr_id = 0;
glm::vec3 lightColor = glm::vec3(1.0f, 1.0f, 1.0f);
glm::vec3 objectColor = glm::vec3(1.0f, 1.0f, 1.0f);
glm::vec3 lightPos = glm::vec3(0.0f, 100.0f, 0.0f);
float lightStr = 200.0;

// Model matrix : an identity matrix (model will be at the origin)
glm::mat4 Model = glm::mat4(1.0f);

void processInput(GLFWwindow* window);
glm::vec3 calculateNormalForVertex(float* vertices, int row, int col, int nrows, int ncols, glm::vec3 centerVertex);
float* prepareNormals(float* vertices, int nrows, int ncols);
unsigned int* prepareIndicies(int ncols, int nrows);

void APIENTRY glDebugOutput(GLenum source, GLenum type, unsigned int id, GLenum severity,
	GLsizei length, const char* message, const void* userParam);

void error_callback(int code, const char* desc) {
	fprintf(stderr, "ERROR [%d]: %s\n", code, desc);
	exit(EXIT_FAILURE); // Wyrzuca program przy niepoprawnym za³adowaniu GLFW
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
}

void scroll_callback(GLFWwindow* window, double xoffset, double yoffset)
{
	//cout << "xoffset: " << xoffset << endl;
	//cout << "yoffset: " << yoffset << endl;
	float minFOV = 10.0f;
	float maxFOV = 80.0f;
	int scrollSpeed = 2;

	fov -= scrollSpeed * (float)yoffset;
	if (fov < minFOV) {
		fov = minFOV;
	}
	if (fov > maxFOV) {
		fov = maxFOV;
	}
}

unsigned int* prepareIndicies(int ncols, int nrows) {
	unsigned int* indices = new unsigned int[6 * ((ncols-1) * (nrows-1))];
	int indexPos = 0, index = 0;
	int trash;

	for (int row = 0; row < nrows - 1; row++) {
		for (int col = 0; col < ncols - 1; col++) {
			
			indices[indexPos] = (row * nrows) + col;
			indices[indexPos + 1] = (row * nrows) + col+ 1;
			indices[indexPos + 2] = ((row + 1) * nrows) + col;
			indices[indexPos + 3] = (row * nrows) + col + 1;
			indices[indexPos + 4] = ((row + 1) * nrows) + col;
			indices[indexPos + 5] = ((row + 1) * nrows) + col + 1;
			
			/*cout << "Triangle: ";
			cout << indices[indexPos] << ", ";
			cout << indices[indexPos + 1] << "; ";
			cout << indices[indexPos + 2] << endl;

			cin >> trash;

			cout << "Triangle: ";
			cout << indices[indexPos + 3] << ", ";
			cout << indices[indexPos + 4] << "; ";
			cout << indices[indexPos + 5] << endl;

			cin >> trash;*/

			indexPos = indexPos + 6;

			//cout << "indexPos: " << indexPos << endl;

		}
	}

	cout << "Triangles amount: " << indexPos/6 << endl;

	return indices;
}

float* prepareNormals(float* vertices, int nrows, int ncols) {
	glm::vec3 tmpNormal;
	int xIndexInNormals = 0;
	float* normals = (float*)calloc(3 * nrows * ncols, sizeof(float));

	for (int row = 0; row < nrows; row++) {
		for (int col = 0; col < 3*ncols; col+=3) {

			xIndexInNormals += (row * (3 * ncols)) + col;
			tmpNormal = calculateNormalForVertex(vertices, row, col, nrows, ncols, glm::vec3(vertices[xIndexInNormals], vertices[xIndexInNormals + 1], vertices[xIndexInNormals + 2]));
			normals[xIndexInNormals] = tmpNormal.x;
			normals[xIndexInNormals + 1] = tmpNormal.y;
			normals[xIndexInNormals + 2] = tmpNormal.z;
			//cout << "pos in normals = " << (row * (3 * ncols)) + col << endl;
			

			/*if (row == 0 || row == nrows - 1) { // Jesteœmy na jednym z pionowych krañców
				if (col != 0 || col != ncols - 1) { // Jesteœmy na krañcu, ale nie w rogu
					// Wziêcie punktów z vertices na podstawie indices
				}
				else { // Jesteœmy w rogu
					// Wziêcie punktów z vertices na podstawie indices
				}
			}
			else if (col == 0 || col == ncols - 1) { // Jesteœmy na jednym z poziomych krañców
				if (row != 0 || row != nrows - 1) { // Jesteœmy na krañcu, ale nie w rogu
					// Wziêcie punktów z vertices na podstawie indices
				}
				else { // Jesteœmy w rogu
					// Wziêcie punktów z vertices na podstawie indices
				}
			}*/
		}
	}



	//normals	
	/*
	for (int i = 600; i < (3 * nrows * ncols) - 600; i = i + 3)
	{
		cout << "X pos in normals = " << i << endl;
		if (i % 600 == 0 || i % 600 == 599)
		{
			normals[i + 1] = 1;
		}
		else
		{
			glm::vec3 x(vertices[i], vertices[i + 1], vertices[i + 2]);
			glm::vec3 above(vertices[i + 600], vertices[i + 601], vertices[i + 602]);
			glm::vec3 right(vertices[i + 3], vertices[i + 4], vertices[i + 5]);
			glm::vec3 below(vertices[i - 600], vertices[i - 599], vertices[i - 598]);
			glm::vec3 left(vertices[i - 3], vertices[i - 2], vertices[i - 1]);

			glm::vec3 normal1 = glm::cross(above - x, left - x);
			glm::vec3 normal2 = glm::cross(left - x, below - x);
			glm::vec3 normal3 = glm::cross(below - x, right - x);
			glm::vec3 normal4 = glm::cross(right - x, above - x);

			normals[i] = normal1[0]  +normal2[0] + normal3[0] + normal4[0];
			normals[i + 1] = normal1[1] + normal2[1] + normal3[1] + normal4[1];
			normals[i + 2] = normal1[2] + normal2[2] + normal3[2] + normal4[2];
		}
	}
	*/

	return normals;
}

glm::vec3 calculateNormalForVertex(float* vertices, int row, int col, int nrows, int ncols, glm::vec3 centerVertex) {
	int tmpRow, tmpCol, posX;
	tmpRow = row;
	tmpCol = col;

	glm::vec3 above(0,0,0);
	glm::vec3 below(0,0,0);
	glm::vec3 left(0,0,0);
	glm::vec3 right(0,0,0);
	glm::vec3 normalAL(0,0,0);
	glm::vec3 normalBL(0,0,0);
	glm::vec3 normalAR(0,0,0);
	glm::vec3 normalBR(0,0,0);
	glm::vec3 normal(0, 0, 0);
	
	// AdjacentVertices
	if ((tmpRow - 1) >= 0) {
		// above
		posX = ((row - 1) * (3 * ncols) + col);
		above = glm::vec3(vertices[posX], vertices[posX + 1], vertices[posX + 2]);
		//cout << "above: (" << above.x << ", " << above.y << ", " << above.z << ")" << endl;
	}
	if ((tmpRow + 1) <= nrows) {
		// below
		posX = ((row + 1) * (3 * ncols) + col);
		below = glm::vec3(vertices[posX], vertices[posX + 1], vertices[posX + 2]);
		//cout << "below: (" << below.x << ", " << below.y << ", " << below.z << ")" << endl;
	}
	if ((tmpCol - 1) >= 0) {
		// left
		posX = (row * ((3 * ncols) - 1) + col);
		left = glm::vec3(vertices[posX], vertices[posX + 1], vertices[posX + 2]);
		//cout << "left: (" << left.x << ", " << left.y << ", " << left.z << ")" << endl;
	}
	if ((tmpCol + 1) <= ncols) {
		// right
		posX = (row * ((3 * ncols) + 1) + col);
		right = glm::vec3(vertices[posX], vertices[posX + 1], vertices[posX + 2]);
		//right = glm::vec3(vertices[(row * ncols + (ncols + 1))], vertices[(row * ncols + (ncols + 1)) + 1], vertices[(row * ncols + (ncols + 1)) + 2]);
		//cout << "right: (" << right.x << ", " << right.y << ", " << right.z << ")" << endl;
	}

	// NormalsForDirections
	if (above != glm::vec3(0, 0, 0) && left != glm::vec3(0, 0, 0)) {
		// normalAL
		normalAL = glm::normalize(glm::cross(above - centerVertex, left - centerVertex));
		//cout << "normalAL: (" << normalAL.x << ", " << normalAL.y << ", " << normalAL.z << ")" << endl;
	}
	if (below != glm::vec3(0, 0, 0) && left != glm::vec3(0, 0, 0)) {
		// normalBL
		normalBL = glm::normalize(glm::cross(below - centerVertex, left - centerVertex));
		//cout << "normalBL: (" << normalBL.x << ", " << normalBL.y << ", " << normalBL.z << ")" << endl;
	}
	if (above != glm::vec3(0, 0, 0) && right != glm::vec3(0, 0, 0)) {
		// normalAR
		normalAR = glm::normalize(glm::cross(above - centerVertex, right - centerVertex));
		//cout << "normalAR: (" << normalAR.x << ", " << normalAR.y << ", " << normalAR.z << ")" << endl;
	}
	if (below != glm::vec3(0, 0, 0) && right != glm::vec3(0, 0, 0)) {
		// normalBR
		normalBR = glm::normalize(glm::cross(below - centerVertex, right - centerVertex));
		//cout << "normalBR: (" << normalBR.x << ", " << normalBR.y << ", " << normalBR.z << ")" << endl;
	}
	
	// NormalForCenterVertex
	if (normalAL != glm::vec3(0, 0, 0)) {
		normal.x += normalAL.x;
		normal.y += normalAL.y;
		normal.z += normalAL.z;
	}
	if (normalAR != glm::vec3(0, 0, 0)) {
		normal.x += normalAR.x;
		normal.y += normalAR.y;
		normal.z += normalAR.z;
	}
	if (normalBL != glm::vec3(0, 0, 0)) {
		normal.x += normalBL.x;
		normal.y += normalBL.y;
		normal.z += normalBL.z;
	}
	if (normalBR != glm::vec3(0, 0, 0)) {
		normal.x += normalBR.x;
		normal.y += normalBR.y;
		normal.z += normalBR.z;
	}
	//cout << "normal: (" << normal.x << ", " << normal.y << ", " << normal.z << ")" << endl;

	//cout << "normal nr: " << (row * (3 * ncols) + col) / 3 << endl;

	return normal;
}

void APIENTRY glDebugOutput(GLenum source,
	GLenum type,
	unsigned int id,
	GLenum severity,
	GLsizei length,
	const char* message,
	const void* userParam)
{
	// ignore non-significant error/warning codes
	if (id == 131169 || id == 131185 || id == 131218 || id == 131204) return;

	std::cout << "---------------" << std::endl;
	std::cout << "Debug message (" << id << "): " << message << std::endl;

	switch (source)
	{
	case GL_DEBUG_SOURCE_API:             std::cout << "Source: API"; break;
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   std::cout << "Source: Window System"; break;
	case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout << "Source: Shader Compiler"; break;
	case GL_DEBUG_SOURCE_THIRD_PARTY:     std::cout << "Source: Third Party"; break;
	case GL_DEBUG_SOURCE_APPLICATION:     std::cout << "Source: Application"; break;
	case GL_DEBUG_SOURCE_OTHER:           std::cout << "Source: Other"; break;
	} std::cout << std::endl;

	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:               std::cout << "Type: Error"; break;
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout << "Type: Deprecated Behaviour"; break;
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  std::cout << "Type: Undefined Behaviour"; break;
	case GL_DEBUG_TYPE_PORTABILITY:         std::cout << "Type: Portability"; break;
	case GL_DEBUG_TYPE_PERFORMANCE:         std::cout << "Type: Performance"; break;
	case GL_DEBUG_TYPE_MARKER:              std::cout << "Type: Marker"; break;
	case GL_DEBUG_TYPE_PUSH_GROUP:          std::cout << "Type: Push Group"; break;
	case GL_DEBUG_TYPE_POP_GROUP:           std::cout << "Type: Pop Group"; break;
	case GL_DEBUG_TYPE_OTHER:               std::cout << "Type: Other"; break;
	} std::cout << std::endl;

	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH:         std::cout << "Severity: high"; break;
	case GL_DEBUG_SEVERITY_MEDIUM:       std::cout << "Severity: medium"; break;
	case GL_DEBUG_SEVERITY_LOW:          std::cout << "Severity: low"; break;
	case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout << "Severity: notification"; break;
	} std::cout << std::endl;
	std::cout << std::endl;
}

int main(){
	int ncols, nrows, verticesFSize, indicesFSize;
	float* verticesF;
	float* normals;
	unsigned int* indicesF;
	
	//if(daneZPliku == true)
	// Wczytanie informacji z pliku
	ncols = getNcols();
	nrows = getNrows();
	verticesF = loadVertices();
	verticesFSize = 3 * nrows * ncols;

	normals = prepareNormals(verticesF, nrows, ncols);

	//else{}
	/*
		1. Podanie z klawiatury wymiarów generowanego terenu i przypisanie do ncols, nrows
		2. Uruchomienie algorytmu generuj¹cego wysokoœci
	*/
	
	indicesF = prepareIndicies(ncols, nrows);
	indicesFSize = 6 * ((ncols - 1) * (nrows - 1));

	int width=968, height=800;
	//int width=1920, height=1080; 

	glfwSetErrorCallback(error_callback); 
	//glfwPollEvents(); //<- wywo³uje b³¹d inicjalizacji i rzuca b³¹d, który obs³uguje mój callback

// GLFW
	glfwInit();

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	glfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Wy³¹czenie zmiany rozmiaru okna
	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Coœ dla Maca

	//GLFWwindow* window = NULL;
	//GLFWwindow* window = glfwCreateWindow(0, 0, "OpenGL", NULL, NULL); 
	GLFWwindow* window = glfwCreateWindow(width, height, "OpenGL", NULL, NULL); 
	if (window == NULL)
	{
		//return -1;
		fprintf(stderr, "ERROR: window creation error");
		exit(EXIT_FAILURE);
	}
	
	glfwMakeContextCurrent(window);
	glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
	glfwSetScrollCallback(window, scroll_callback);

// GLEW
	//glewExperimental = GL_TRUE;
	GLenum err = glewInit();
	if (err != GLEW_OK)
	{
		// Problem: glewInit failed, something is seriously wrong.
		fprintf(stderr, "ERROR: %s\n", glewGetErrorString(err));
	} 
		
	fprintf(stdout, "Status: Using GLEW %s\n", glewGetString(GLEW_VERSION));

	int flags; glGetIntegerv(GL_CONTEXT_FLAGS, &flags);

	if (flags & GL_CONTEXT_FLAG_DEBUG_BIT)
	{
		printf("Debug context created!\n");
		glEnable(GL_DEBUG_OUTPUT);
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glDebugMessageCallback(glDebugOutput, nullptr);
		glDebugMessageControl
			(GL_DEBUG_SOURCE_API,
			GL_DEBUG_TYPE_ERROR,
			GL_DEBUG_SEVERITY_HIGH,
			0, nullptr, GL_TRUE);
	}

//^^^ Init code

// OpenGL settings
	
	/* Info about OpenGL */
	/*
	const GLubyte* renderer;
	const GLubyte* version;
	renderer = glGetString(GL_RENDERER);
	version = glGetString(GL_VERSION);
	printf("Renderer: %s\n", renderer);
	printf("OpenGL version supported %s\n", version);
	*/

	// Vertices array
	float vertices[] = {
	-1.0f,-1.0f,-1.0f, // triangle 1 : begin
	-1.0f,-1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f, // triangle 1 : end
	1.0f, 1.0f,-1.0f, // triangle 2 : begin
	-1.0f,-1.0f,-1.0f,
	-1.0f, 1.0f,-1.0f, // triangle 2 : end
	1.0f,-1.0f, 1.0f,
	-1.0f,-1.0f,-1.0f,
	1.0f,-1.0f,-1.0f,
	1.0f, 1.0f,-1.0f,
	1.0f,-1.0f,-1.0f,
	-1.0f,-1.0f,-1.0f,
	-1.0f,-1.0f,-1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f,-1.0f,
	1.0f,-1.0f, 1.0f,
	-1.0f,-1.0f, 1.0f,
	-1.0f,-1.0f,-1.0f,
	-1.0f, 1.0f, 1.0f,
	-1.0f,-1.0f, 1.0f,
	1.0f,-1.0f, 1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f,-1.0f,-1.0f,
	1.0f, 1.0f,-1.0f,
	1.0f,-1.0f,-1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f,-1.0f, 1.0f,
	1.0f, 1.0f, 1.0f,
	1.0f, 1.0f,-1.0f,
	-1.0f, 1.0f,-1.0f,
	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f,-1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f, 1.0f, 1.0f,
	-1.0f, 1.0f, 1.0f,
	1.0f,-1.0f, 1.0f
	};

	unsigned int shaderProgram = glCreateProgram();
	
	shaderProgram = loadShaders("vertex_shader.glsl", "fragment_shader.glsl");

	GLuint VAO, VBO, EBO, VBO_normals;
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);
	glGenBuffers(1, &VBO_normals);

	cout << "sizeof(verticesF) = " << verticesFSize << endl;

	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	glBufferData(GL_ARRAY_BUFFER, verticesFSize * sizeof(float), verticesF, GL_STATIC_DRAW);
	
	printf("VBOID: %u\n", VBO);

	cout << "sizeof(indicesF) = " << indicesFSize << endl;

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesFSize * sizeof(int), indicesF, GL_STATIC_DRAW);
	
	printf("EBOID: % u\n", EBO);

	glBindBuffer(GL_ARRAY_BUFFER, VBO_normals);
	glBufferData(GL_ARRAY_BUFFER, verticesFSize * sizeof(float), normals, GL_STATIC_DRAW);

	printf("VBO_normalsID: % u\n", VBO_normals);

	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

	glBindBuffer(GL_ARRAY_BUFFER, VBO_normals);
	glEnableVertexAttribArray(2);
	glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (void*)0);

	glBindVertexArray(0);
	
	//cout << glGetError() << endl;

// Main loop
	while (!glfwWindowShouldClose(window)){
		processInput(window);

		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		
		glUseProgram(shaderProgram);

		//cout << "error" << endl;
		//cout << glGetError() << endl; <- kod po 
		
		// Projection matrix : 45° Field of View, 4:3 ratio, display range : 0.1 unit <-> 100 units
		glm::mat4 Projection = glm::perspective(glm::radians(fov), (float)width / (float)height, 0.1f, 1000.0f);

		// Camera matrix
		glm::mat4 View = glm::lookAt(cameraPos, glm::vec3(0,0,0), cameraUp);

		// Our ModelViewProjection : multiplication of our 3 matrices
		glm::mat4 mvp = Projection * View * Model; // Remember, matrix multiplication is the other way around

		// Get a handle for our "MVP" uniform
		// Only during the initialisation
		GLuint MatrixID = glGetUniformLocation(shaderProgram, "MVP");

		// Send our transformation to the currently bound shader, in the "MVP" uniform
		// This is done in the main loop since each model will have a different MVP matrix (At least for the M part)
		glUniformMatrix4fv(MatrixID, 1, GL_FALSE, &mvp[0][0]);

		// Lighting
		lightColor_id = glGetUniformLocation(shaderProgram, "lightColor");
		lightPos_id = glGetUniformLocation(shaderProgram, "lightPos");
		lightStr_id = glGetUniformLocation(shaderProgram, "lightStr");
		objectColor_id = glGetUniformLocation(shaderProgram, "objectColor");

		glUniform3fv(lightColor_id, 1, &lightColor[0]);
		glUniform3fv(lightPos_id, 1, &lightPos[0]);
		glUniform1f(lightStr_id, lightStr);
		glUniform3fv(objectColor_id, 1, &objectColor[0]);
		//

		glBindVertexArray(VAO);

		//cout << "Indices amount " << 6 * ((ncols - 1) * (nrows - 1)) << endl;
		glDrawElements(GL_TRIANGLES, 6 * ((ncols - 1) * (nrows - 1)), GL_UNSIGNED_INT, 0);
		//glDrawArrays(GL_TRIANGLES, 0, 12 * 3);

		//cout << "errorAfterDraw" << endl;

		glFlush();
		glfwSwapBuffers(window);
		glfwPollEvents();
	}
	
	glfwTerminate();

	return 0;
}

void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);

	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
	{
		//cout << "W" << endl; 
		//cout << "cameraPos.y: " << cameraPos.y << endl;
		//cameraPos += cameraSpeed * cameraFront; // Przybli¿anie(?)
		cameraPos.y += cameraSpeed; // Ruch kamery w górê
		//cameraPos.z += cameraSpeed; // Ruch kamery do przodu
		//cameraPos = glm::normalize(glm::cross(cameraFront, glm::normalize(glm::cross(cameraFront, cameraUp))))* cameraSpeed;
		//cameraFront.y -= cameraSpeed;
	}
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
	{
		//cout << "S" << endl;
		//cameraPos -= cameraSpeed * cameraFront; // Oddalanie(?)
		cameraPos.y -= cameraSpeed; // Ruch kamery w dó³
		//cameraPos.z -= cameraSpeed; // Ruch kamery do przodu
	}
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
	{
		//cout << "A" << endl;
		//cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; // Ruch kamery w lewo
		cameraPos.x -= cameraSpeed; // Ruch kamery w górê
	}
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
	{
		//cout << "D" << endl;
		cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed; // Ruch kamery w prawo       
	}
	if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS)
	{
		//cout << "Q" << endl;
		Model = glm::rotate(Model, glm::radians(rotationMultiplier * cameraSpeed), glm::vec3(0.0f,1.0f,0.0f)); // Obrót kamery w lewo      
	}
	if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)
	{
		//cout << "E" << endl;
		Model = glm::rotate(Model, glm::radians(rotationMultiplier * -cameraSpeed), glm::vec3(0.0f, 1.0f, 0.0f)); // Obrót kamery w lewo      
	}if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
	{
		//cout << "strza³ka w górê" << endl; 
		cameraPos.z -= cameraSpeed; // Ruch kamery do przodu
		cameraFront.z += cameraSpeed;
	}
	if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
	{
		//cout << "strza³ka do ty³u" << endl;
		cameraPos.z += cameraSpeed; // Ruch kamery do ty³u
		cameraFront.z -= cameraSpeed;
	}
}