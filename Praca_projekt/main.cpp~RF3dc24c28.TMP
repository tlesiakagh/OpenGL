#include <glew.h>
#include <glfw3.h>

#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <numeric>

#include "shaderLoader.h"
#include "fileReader.h"

//funkcje algebry liniowej
#include "glm/vec3.hpp" 
#include "glm/vec4.hpp" 
#include "glm/mat4x4.hpp" 
#include "glm/gtc/matrix_transform.hpp"

using namespace std;

glm::vec3 cameraPos = glm::vec3(0.0f, 1.0f, 3.0f);
glm::vec3 cameraFront = glm::vec3(0.0f, 0.0f, -1.0f);
glm::vec3 cameraUp = glm::vec3(0.0f, 1.0f, 0.0f);

void processInput(GLFWwindow* window);

void APIENTRY glDebugOutput(GLenum source, GLenum type, unsigned int id, GLenum severity,
	GLsizei length, const char* message, const void* userParam);

void error_callback(int code, const char* desc) {
	fprintf(stderr, "ERROR [%d]: %s\n", code, desc);
	exit(EXIT_FAILURE); // Wyrzuca program przy niepoprawnym za³adowaniu GLFW
}

void framebuffer_size_callback(GLFWwindow* window, int width, int height)
{
	glViewport(0, 0, width, height);
} 

unsigned int* prepareIndicies(int ncols, int nrows) {
	unsigned int* indices = new unsigned int[6 * ((ncols - 1) * (nrows - 1))];
	int indexPos = 0;
	int index = 0;

	cout << "Triangles amount: " << 2 * ((ncols - 1) * (nrows - 1)) << endl;

	for (int i = 0; i < nrows - 1; i++) {
		for (int j = 0; j < ncols - 1; j++) {
			
			indices[indexPos] = (i * nrows) + j;
			indices[indexPos + 1] = (i * nrows) + j+ 1;
			indices[indexPos + 2] = ((i + 1) * nrows) + j;
			indices[indexPos + 3] = (i * nrows) + j + 1;
			indices[indexPos + 4] = ((i + 1) * nrows) + j;
			indices[indexPos + 5] = ((i + 1) * nrows) + j + 1;

			indexPos = indexPos + 6;

			//cout << "indexPos: " << indexPos << endl;

		}
	}

	return indices;
}


void APIENTRY glDebugOutput(GLenum source,
	GLenum type,
	unsigned int id,
	GLenum severity,
	GLsizei length,
	const char* message,
	const void* userParam)
{
	// ignore non-significant error/warning codes
	if (id == 131169 || id == 131185 || id == 131218 || id == 131204) return;

	std::cout << "---------------" << std::endl;
	std::cout << "Debug message (" << id << "): " << message << std::endl;

	switch (source)
	{
	case GL_DEBUG_SOURCE_API:             std::cout << "Source: API"; break;
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   std::cout << "Source: Window System"; break;
	case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout << "Source: Shader Compiler"; break;
	case GL_DEBUG_SOURCE_THIRD_PARTY:     std::cout << "Source: Third Party"; break;
	case GL_DEBUG_SOURCE_APPLICATION:     std::cout << "Source: Application"; break;
	case GL_DEBUG_SOURCE_OTHER:           std::cout << "Source: Other"; break;
	} std::cout << std::endl;

	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:               std::cout << "Type: Error"; break;
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout << "Type: Deprecated Behaviour"; break;
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  std::cout << "Type: Undefined Behaviour"; break;
	case GL_DEBUG_TYPE_PORTABILITY:         std::cout << "Type: Portability"; break;
	case GL_DEBUG_TYPE_PERFORMANCE:         std::cout << "Type: Performance"; break;
	case GL_DEBUG_TYPE_MARKER:              std::cout << "Type: Marker"; break;
	case GL_DEBUG_TYPE_PUSH_GROUP:          std::cout << "Type: Push Group"; break;
	case GL_DEBUG_TYPE_POP_GROUP:           std::cout << "Type: Pop Group"; break;
	case GL_DEBUG_TYPE_OTHER:               std::cout << "Type: Other"; break;
	} std::cout << std::endl;

	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH:         std::cout << "Severity: high"; break;
	case GL_DEBUG_SEVERITY_MEDIUM:       std::cout << "Severity: medium"; break;
	case GL_DEBUG_SEVERITY_LOW:          std::cout << "Severity: low"; break;
	case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout << "Severity: notification"; break;
	} std::cout << std::endl;
	std::cout << std::endl;
}

int main(){
	int ncols, nrows;
	float* verticesF;
	unsigned int* indicesF;
	
	//if(daneZPliku == true)
	// Wczytanie informacji z pliku
	ncols = getNcols();
	nrows = getNrows();
	verticesF = loadVertices();
	//else{}
	/*
		1. Podanie z klawiatury wymiarów generowanego terenu i przypisanie do ncols, nrows
		2. Uruchomienie algorytmu generuj¹cego wysokoœci
	*/
	
	indicesF = prepareIndicies(ncols, nrows);

	/*for (int i = 0; i < 6 * ((5 - 1) * (5 - 1)); i++) {
		cout << indicesF[i] << ",";
	}*/

	int width=968, height=800;
	//int width=1920, height=1080; 

	glfwSetErrorCallback(error_callback); 
	//glfwPollEvents(); //<- wywo³uje b³¹d inicjalizacji i rzuca b³¹d, który obs³uguje mój callback

// GLFW
	glfwInit();

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 4);
	glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
	glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, true);
	//sglfwWindowHint(GLFW_RESIZABLE, GL_FALSE); // Wy³¹czenie zmiany rozmiaru okna
	//glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // Coœ dla Maca

	//GLFWwindow* window = NULL;
	//GLFWwindow* window = glfwCreateWindow(0, 0, "OpenGL", NULL, NULL); 
	GLFWwindow* window = glfwCreateWindow(width, height, "OpenGL", NULL, NULL); 
	if (window == NULL)
	{
		//return -1;
		fprintf(stderr, "ERROR: window creation error");
		exit(EXIT_FAILURE);
	}
	
	glfwMakeContextCurrent(window);
	//glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);

// GLEW
	//glewExperimental = GL_TRUE;
	GLenum err = glewInit();
	if (err != GLEW_OK)
	{
		// Problem: glewInit failed, something is seriously wrong.
		fprintf(stderr, "ERROR: %s\n", glewGetErrorString(err));
	} 
		
	fprintf(stdout, "Status: Using GLEW %s\n", glewGetString(GLEW_VERSION));

//^^^ Init code

// OpenGL settings
	
	/* Info about OpenGL */
	/*
	const GLubyte* renderer;
	const GLubyte* version;
	renderer = glGetString(GL_RENDERER);
	version = glGetString(GL_VERSION);
	printf("Renderer: %s\n", renderer);
	printf("OpenGL version supported %s\n", version);
	*/

	float vertices[] = {
	-0.5f, -0.5f, 0.0f,
	 0.0f, -0.5f, 0.0f,
	 0.0f,  0.0f, 0.0f,
	 0.1f,  0.2f, 0.3f,
	 0.4f,  0.5f, 0.6f,
	 0.7f,  0.8f, 0.9f,
	};


	unsigned int indices[] = {  // note that we start from 0!
			0, 1, 2,
			3, 4, 5,
	};

	unsigned int shaderProgram = glCreateProgram();
	
	shaderProgram = loadShaders("vertex_shader.glsl", "fragment_shader.glsl");

	GLuint VAO, VBO, EBO;
	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glGenBuffers(1, &EBO);

	glBindVertexArray(VAO);

	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	//glBufferData(GL_ARRAY_BUFFER, sizeof(verticesF) / sizeof(float), vertices, GL_STATIC_DRAW);
	
	printf("VBOID: %u\n", VBO);

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
	//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indicesF) / sizeof(unsigned int), indices, GL_STATIC_DRAW);
	
	printf("EBOID: % u\n", EBO);

	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), 0);

	glBindVertexArray(0);

	glEnable(GL_DEPTH_TEST);
	cout << glGetError() << endl;

	// OpenGL debugging init
	int flags; glGetIntegerv(GL_CONTEXT_FLAGS, &flags);

	if (flags & GL_CONTEXT_FLAG_DEBUG_BIT)
	{
		glEnable(GL_DEBUG_OUTPUT);
		glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
		glDebugMessageCallback(glDebugOutput, nullptr);
		glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
	}
	//
	int iter_j = 0, iter_i = 0;
// Main loop
	while (!glfwWindowShouldClose(window)){
		processInput(window);

		glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		
		glUseProgram(shaderProgram);
		

		//cout << "error" << endl;
		//cout << glGetError() << endl; <- kod po 
		
		// Projection matrix : 45° Field of View, 4:3 ratio, display range : 0.1 unit <-> 100 units
		glm::mat4 Projection = glm::perspective(glm::radians(45.0f), (float)width / (float)height, 0.1f, 100.0f);

		// Or, for an ortho camera :
		//glm::mat4 Projection = glm::ortho(-10.0f,10.0f,-10.0f,10.0f,0.0f,100.0f); // In world coordinates

		// Camera matrix
		glm::mat4 View = glm::lookAt(cameraPos, cameraPos + cameraFront, cameraUp);

		// Model matrix : an identity matrix (model will be at the origin)
		glm::mat4 Model = glm::mat4(1.0f);

		// Our ModelViewProjection : multiplication of our 3 matrices
		glm::mat4 mvp = Projection * View * Model; // Remember, matrix multiplication is the other way around

		/*cout << "[";
		for (iter_i; iter_i < 4; iter_i++) {
			for (iter_j = 0; iter_j < 4; iter_j++) {
				cout << "[" << mvp[iter_i][iter_j] << "]";
			}
			//cout << "]" << endl;
		}*/

		// Get a handle for our "MVP" uniform
		// Only during the initialisation
		GLuint MatrixID = glGetUniformLocation(shaderProgram, "MVP");

		// Send our transformation to the currently bound shader, in the "MVP" uniform
		// This is done in the main loop since each model will have a different MVP matrix (At least for the M part)
		glUniformMatrix4fv(MatrixID, 1, GL_FALSE, &mvp[0][0]);

		glBindVertexArray(VAO);

		glDrawElements(GL_TRIANGLES, sizeof(indices)/sizeof(indices[0]), GL_UNSIGNED_INT, 0);
		//cout << sizeof(indices) / sizeof(indices[0]);
		//glDrawElements(GL_TRIANGLE_STRIP, sizeof(indicesF)/sizeof(indicesF[0]), GL_UNSIGNED_INT, 0);
		
		//cout << "errorAfterDraw" << endl;

		glFlush();
		glfwSwapBuffers(window);
		glfwPollEvents();
	}
	
	glfwTerminate();

	return 0;
}

void processInput(GLFWwindow* window)
{
	if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
		glfwSetWindowShouldClose(window, true);

	const float cameraSpeed = 0.05f; // adjust accordingly
	if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
	{
		//cout << "W" << endl;
		cameraPos += cameraSpeed * cameraFront;
	}
	if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
	{
		//cout << "S" << endl;
		cameraPos -= cameraSpeed * cameraFront;
	}
	if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
	{
		//cout << "A" << endl;
		cameraPos -= glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
	}
	if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
	{
		//cout << "D" << endl;
		cameraPos += glm::normalize(glm::cross(cameraFront, cameraUp)) * cameraSpeed;
	}
}